> git init
To initialize a Git repository here. Creates an empty repository in /.git/. The repository is a hidden directory where Git operates.

$ git status
to see what the current state of our project is
Notice how Git says octocat.txt is "untracked"? That means Git sees that octocat.txt is a new file.

$ git add octocat.txt
add it to the staging area by using git add

$ git status
Notice how Git says changes to be committed?
The files listed here are in the Staging Area, and they are not in our repository yet. We could add or remove files from the stage before we store them in the repository.

$ git commit -m"Add cute octocat story"
To store our staged changes we run the commit command with a message describing what we've changed.

$ git add '*.txt'
Luckily, we can add all the new files using a wildcard with git add. Don't forget the quotes!

$ git commit -m 'And all the octocat txt files'
Committing All Changes

$ git log
Think of Git's log as a journal that remembers all the changes we've committed so far, in the order we committed them.

$ git remote add origin https://github.com/try-git/try_git.git
To push our local repo to the GitHub server we'll need to add a remote repository.

$ git push -u origin master
The push command tells Git where to put our commits when we're ready, and boy we're ready. So let's push our local changes to our origin repo (on GitHub).
The name of our remote is origin and the default local branch name is master. The -u tells Git to remember the parameters, so that next time we can simply run git push and Git will know what to do.

$ git pull origin master
We can check for changes on our GitHub repository and pull down any new changes

> git diff HEAD
Let's take a look at what is different from our last commit by using the git diff command.
In this case we want the diff of our most recent commit, which we can refer to using the HEAD pointer

$ git add octofamily/octodog.txt
Another great use for diff is looking at changes within files that have already been staged. Remember, staged files are files we have told git that are ready to be committed.
Let's use git add to stage octofamily/octodog.txt,

$ git diff --staged
git diff with the --staged option to see the changes you just staged

$ git reset octofamily/octodog.txt
You can unstage files by using the git reset command

$ git checkout -- octocat.txt
Files can be changed back to how they were at the last commit by using the command: git checkout -- <target>

$ git branch clean_up
When developers are working on a feature or bug they'll often create a copy (aka. branch) of their code they can make separate commits to. Then when they're done they can merge this branch back into their main master branch.

$ git checkout clean_up
Now if you type git branch you'll see two local branches: a main branch named master and your new branch named clean_up.
You can switch branches using the git checkout <branch> command.

$ git rm '*.txt'
You can finally remove all those pesky octocats by using the git rm command which will not only remove the actual files from disk, but will also stage the removal of the files for us.

$ git commit -m "Removeall the cats"
Now that you've removed all the cats you'll need to commit your changes

$ git checkout master
switch back to the master branch so you can copy (or merge) your changes from the clean_up branch back into the master branch

$ git merge clean_up
We're already on the master branch, so we just need to tell Git to merge the clean_up branch into it:

$ git branch -d clean_up
You can use git branch -d <branch name> to delete a branch.

> git push
push everything you've been working on to your remote repository
